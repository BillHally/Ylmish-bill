module Ylmish.Program

//open Expect.Elmish
open Elmish
open FSharp.Data.Adaptive
open Yjs

open Ylmish
open Ylmish.Adaptive.Codec

#if FABLE_COMPILER
open Fable.Mocha
#else
open Expecto
#endif

module Example =

    type Message =
        | SetPropA of string
        | SetPropB of string option

    type Model = {
        PropA : string
        PropB : string option
        PropC : IndexList<Submodel>
    }
    and Submodel = {
        Prop0 : string
    }

    let update msg model =
        match msg with
        | SetPropA value ->
            { model with PropA = value }
        | SetPropB value ->
            { model with PropB = value }

    let view _ _ = ()


    /// An adaptified version of Model generated by Adaptify.
    type AdaptiveModel(value : Model) =
        let _propA_ = FSharp.Data.Adaptive.cval(value.PropA)
        let _propB_ = FSharp.Data.Adaptive.cval(value.PropB)
        let _propC_ =
            let inline __arg2 (m : AdaptiveSubmodel) (v : Submodel) =
                m.Update(v)
                m
            FSharp.Data.Traceable.ChangeableModelList(value.PropC, (fun (v : Submodel) -> AdaptiveSubmodel(v)), __arg2, (fun (m : AdaptiveSubmodel) -> m))
        let mutable __value = value
        let __adaptive = FSharp.Data.Adaptive.AVal.custom((fun (_ : FSharp.Data.Adaptive.AdaptiveToken) -> __value))
        static member Create(value : Model) = AdaptiveModel(value)
        member __.Update(value : Model) =
            if Microsoft.FSharp.Core.Operators.not((FSharp.Data.Adaptive.ShallowEqualityComparer<Model>.ShallowEquals(value, __value))) then
                __value <- value
                __adaptive.MarkOutdated()
                _propA_.Value <- value.PropA
                _propB_.Value <- value.PropB
                _propC_.Update(value.PropC)
        member __.Current = __adaptive
        member __.propA = _propA_ :> FSharp.Data.Adaptive.aval<Microsoft.FSharp.Core.string>
        member __.propB = _propB_ :> FSharp.Data.Adaptive.aval<Microsoft.FSharp.Core.string option>
        member __.propC = _propC_ :> FSharp.Data.Adaptive.alist<AdaptiveSubmodel>
    and AdaptiveSubmodel(value : Submodel) =
        let _prop0_ = FSharp.Data.Adaptive.cval(value.Prop0)
        let mutable __value = value
        let __adaptive = FSharp.Data.Adaptive.AVal.custom((fun (_ : FSharp.Data.Adaptive.AdaptiveToken) -> __value))
        static member Create(value : Submodel) = AdaptiveSubmodel(value)
        member __.Update(value : Submodel) =
            if Microsoft.FSharp.Core.Operators.not((FSharp.Data.Adaptive.ShallowEqualityComparer<Submodel>.ShallowEquals(value, __value))) then
                __value <- value
                __adaptive.MarkOutdated()
                _prop0_.Value <- value.Prop0
        member __.Current = __adaptive
        member __.prop0 = _prop0_ :> FSharp.Data.Adaptive.aval<Microsoft.FSharp.Core.string>

    let program (opts : {| Init : _; Doc: _; Encode : _; Decode : _ |} )=
        Program.mkSimple (fun () -> opts.Init) update view
        |> Program.withYlmish {
            Create = AdaptiveModel.Create
            Update = fun a b -> a.Update b
            Encode = opts.Encode
            Decode = opts.Decode
            Doc = opts.Doc
        }
        |> Program.test

    let dispatch (dispatcher : Program.ElmishDispatcher<_,_>) msg =
        dispatcher.Dispatch <| Ylmish.Program.Message.User msg

let tests = testList "Program" [
    test "withYlmish persists initial value" {
        let doc = Y.Doc.Create ()
        let value = "initial"
        use dispatcher = Example.program {|
            Init = {
                PropA = value
                PropB = None
                PropC = IndexList.empty
            }
            Doc = doc
            // or encoded = Element<'a where 'a = _ option aval>
            Encode = fun m -> Encode.object [
                "propA", m.propA |> Encode.value id
            ]
            Decode = Decode.object {
                let! propA = Decode.key "propA" (Decode.required <| Decode.value Decoder.id)
                return {
                    PropA = propA
                    PropB = None
                    PropC = IndexList.empty
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (value) (dispatcher.Model.PropA) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propA")) "Y.Doc value"
        
    }

    test "withYlmish restores value" {
        let doc = Y.Doc.Create ()
        let value = doc.getMap().set("propA", "persisted")
        use dispatcher = Example.program {|
            Init = {
                PropA = "initial"
                PropB = None
                PropC = IndexList.empty
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propA", m.propA |> Encode.value id
            ]
            Decode = Decode.object {
                let! propA = Decode.key "propA" (Decode.required <| Decode.value Decoder.id)
                return {
                    PropA = propA
                    PropB = None
                    PropC = IndexList.empty
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (value) (dispatcher.Model.PropA) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propA")) "Y.Doc value"       
    }

    test "withYlmish restores optional value" {
        let doc = Y.Doc.Create ()
        let value = doc.getMap().set("propB", "persisted")
        use dispatcher = Example.program {|
            Init = {
                PropA = "unused"
                PropB = None
                PropC = IndexList.empty
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propB", Encode.option m.propB
            ]
            Decode = Decode.object {
                let! propB = Decode.key "propB" (Decode.optional <| Decode.value Decoder.id)
                return {
                    PropA = "unused"
                    PropB = propB
                    PropC = IndexList.empty
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (Some value) (dispatcher.Model.PropB) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propB")) "Y.Doc value"       
    }

    test "withYlmish persists updated value" {
        let doc = Y.Doc.Create ()
        let value = "initial"
        let value' = "updated"
        use dispatcher = Example.program {|
            Init = {
                PropA = value
                PropB = None
                PropC = IndexList.empty
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propA", m.propA |> Encode.value id
            ]
            Decode = Decode.object {
                let! propA = Decode.key "propA" (Decode.required <| Decode.value Decoder.id)
                return {
                    PropA = propA
                    PropB = None
                    PropC = IndexList.empty
                }
            }
        |}

        Example.dispatch dispatcher <| Example.SetPropA value'

        //Promise.awaitAnimationFrame ()

        Expect.equal (value') (dispatcher.Model.PropA) "Model value"
        Expect.equal (Some value') (doc.getMap().get("propA")) "Y.Doc value"       
    }

    test "withYlmish persists optional value" {
        let doc = Y.Doc.Create ()
        let value = "initial"
        use dispatcher = Example.program {|
            Init = {
                PropA = "unused"
                PropB = Some value
                PropC = IndexList.empty
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propB", Encode.option m.propB
            ]
            Decode = Decode.object {
                let! propB = Decode.key "propB" (Decode.optional <| Decode.value Decoder.id)
                return {
                    PropA = "unused"
                    PropB = propB
                    PropC = IndexList.empty
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (Some value) (dispatcher.Model.PropB) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propB")) "Y.Doc value"       
    }

    test "withYlmish persists none value" {
        let doc = Y.Doc.Create ()
        use dispatcher = Example.program {|
            Init = {
                PropA = "unused"
                PropB = Some "initial"
                PropC = IndexList.empty
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propB", Encode.option m.propB
            ]
            Decode = Decode.object {
                let! propB = Decode.key "propB" (Decode.optional <| Decode.value Decoder.id)
                return {
                    PropA = "unused"
                    PropB = propB
                    PropC = IndexList.empty
                }
            }
        |}

        Example.dispatch dispatcher <| Example.SetPropB None

        Expect.equal None (dispatcher.Model.PropB) "Model value"
        Expect.equal None (doc.getMap().get("propB")) "Y.Doc value"       
    }

    test "withYlmish persists initial list" {
        let doc = Y.Doc.Create ()
        let value = "test"
        //let propCitem0 = doc.getMap()
        //let _ = propCitem0.set("prop0", value)
        //let propC = doc.getArray()
        //let _ = propC.push(Array.singleton propCitem0)
        //let _ = doc.getMap().set("propC", propC)
        use dispatcher = Example.program {|
            Init = {
                PropA = "unused"
                PropB = None
                PropC = IndexList.single { Prop0 = value }
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propC", m.propC |> Encode.listWith <| fun m -> Encode.object [
                    "prop0", m.prop0 |> Encode.value id
                ]
            ]
            Decode = Decode.object {
                let! propB = Decode.key "propB" (Decode.optional <| Decode.value Decoder.id)
                return {
                    PropA = "unused"
                    PropB = propB
                    PropC = IndexList.empty
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        let root : Y.Map<Y.Array<Y.Map<string>>> = doc.getMap ()
        Expect.equal value (dispatcher.Model.PropC[0].Prop0) "Model value"
        Expect.equal (Some value) (root.get("propC").Value.get(0).get("prop0")) "Y.Doc value"       
    }
]