module Ylmish.Program

//open Expect.Elmish
open Elmish
//open FSharp.Data.Adaptive
open Yjs

open Ylmish
open Ylmish.Adaptive.Codec

#if FABLE_COMPILER
open Fable.Mocha
#else
open Expecto
#endif

module Example =
    open FSharp.Data.Adaptive

    type Message =
        | SetPropA of string

    type Model = {
        PropA : string
        PropB : string option
    }

    let update msg model =
        match msg with
        | SetPropA value ->
            { model with PropA = value }

    let view _ _ = ()

    /// An adaptified version of Model generated by Adaptify.
    type AdaptiveModel(value : Model) =
        let _propA_ = FSharp.Data.Adaptive.cval(value.PropA)
        let mutable __value = value
        let __adaptive = FSharp.Data.Adaptive.AVal.custom((fun (_ : FSharp.Data.Adaptive.AdaptiveToken) -> __value))
        static member Create(value : Model) = AdaptiveModel(value)
        // static member Unpersist = Adaptify.Unpersist.create (fun (value : Thing) -> AdaptiveThing(value)) (fun (adaptive : AdaptiveThing) (value : Thing) -> adaptive.Update(value))
        member __.Update(value : Model) =
            if Microsoft.FSharp.Core.Operators.not((FSharp.Data.Adaptive.ShallowEqualityComparer<Model>.ShallowEquals(value, __value))) then
                __value <- value
                __adaptive.MarkOutdated()
                _propA_.Value <- value.PropA
        member __.Current = __adaptive
        member __.propA = _propA_ :> FSharp.Data.Adaptive.aval<Microsoft.FSharp.Core.string>

    let program (opts : {| Init : _; Doc: _; Encode : _; Decode : _ |} )=
        Program.mkSimple (fun () -> opts.Init) update view
        |> Program.withYlmish {
            Create = AdaptiveModel.Create
            Update = fun a b -> a.Update b
            Encode = opts.Encode
            Decode = opts.Decode
            Doc = opts.Doc
        }
        |> Program.test

    let dispatch (dispatcher : Program.ElmishDispatcher<_,_>) msg =
        dispatcher.Dispatch <| Ylmish.Program.Message.User msg

let tests = testList "Program" [
    test "withYlmish persists initial value" {
        let doc = Y.Doc.Create ()
        let value = "initial"
        use dispatcher = Example.program {|
            Init = {
                PropA = value
                PropB = None
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propA", Encode.value m.propA
            ]
            Decode = Decode.object {
                let! propA = Decode.object.key ("propA", Decode.value'<string>)
                return {
                    PropA = propA
                    PropB = None
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (value) (dispatcher.Model.PropA) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propA")) "Y.Doc value"
        
    }

    test "withYlmish restores value" {
        let doc = Y.Doc.Create ()
        let value = doc.getMap().set("propA", "persisted")
        use dispatcher = Example.program {|
            Init = {
                PropA = "initial"
                PropB = None
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propA", Encode.value m.propA
            ]
            Decode = Decode.object {
                let! propA = Decode.object.key ("propA", Decode.value'<string>)
                return {
                    PropA = propA
                    PropB = None
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (value) (dispatcher.Model.PropA) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propA")) "Y.Doc value"       
    }

    test "withYlmish restores optional value" {
        let doc = Y.Doc.Create ()
        let value = doc.getMap().set("propB", "persisted")
        use dispatcher = Example.program {|
            Init = {
                PropA = "unused"
                PropB = None
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propB", Encode.value m.propB
            ]
            Decode = Decode.object {
                let z = Decode.optional Decode.value'<string>
                let propB = Decode.object.key ("propA", z)
                return {
                    PropA = "unused"
                    PropB = ()
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (Some value) (dispatcher.Model.PropB) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propB")) "Y.Doc value"       
    }

    test "withYlmish persists updated value" {
        let doc = Y.Doc.Create ()
        let value = "initial"
        let value' = "updated"
        use dispatcher = Example.program {|
            Init = {
                PropA = value
                PropB = None
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propA", Encode.value m.propA
            ]
            Decode = Decode.object {
                let! propA = Decode.object.key ("propA", Decode.value'<string>)
                return {
                    PropA = propA
                    PropB = None
                }
            }
        |}

        Example.dispatch dispatcher <| Example.SetPropA value'

        //Promise.awaitAnimationFrame ()

        Expect.equal (value') (dispatcher.Model.PropA) "Model value"
        Expect.equal (Some value') (doc.getMap().get("propA")) "Y.Doc value"       
    }

    test "withYlmish persists optional value" {
        let doc = Y.Doc.Create ()
        let value = "initial"
        use dispatcher = Example.program {|
            Init = {
                PropA = "unused"
                PropB = Some value
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propB", Encode.value m.propB
            ]
            Decode = Decode.object {
                let z = Decode.optional Decode.value'<string>
                let propB = Decode.object.key ("propA", z)
                return {
                    PropA = "unused"
                    PropB = ()
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (Some value) (dispatcher.Model.PropB) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propB")) "Y.Doc value"       
    }

    test "withYlmish persists none value" {
        let doc = Y.Doc.Create ()
        use dispatcher = Example.program {|
            Init = {
                PropA = "unused"
                PropB = Some value
            }
            Doc = doc
            Encode = fun m -> Encode.object [
                "propB", Encode.value m.propB
            ]
            Decode = Decode.object {
                let z = Decode.optional Decode.value'<string>
                let propB = Decode.object.key ("propA", z)
                return {
                    PropA = "unused"
                    PropB = ()
                }
            }
        |}

        //Promise.awaitAnimationFrame ()

        Expect.equal (Some value) (dispatcher.Model.PropB) "Model value"
        Expect.equal (Some value) (doc.getMap().get("propB")) "Y.Doc value"       
    }
]